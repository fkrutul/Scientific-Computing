#reader(lib"read.ss""wxme")WXME0109 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 7.6 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 33 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(0
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(1
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 29 #"drscheme:bindings-snipclass%\0"
1 0 101
(2
 #"((lib \"ellipsis-snip.rkt\" \"drracket\" \"private\") (lib \"ellipsi"
 #"s-snip-wxme.rkt\" \"drracket\" \"private\"))\0"
) 2 0 88
(3
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 55
#"((lib \"snip.rkt\" \"pict\") (lib \"snip-wxme.rkt\" \"pict\"))\0"
1 0 34 #"(lib \"bullet-snip.rkt\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 29 #"drclickable-string-snipclass\0"
0 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 57 0 1 #"\0"
0 75 1 #"\0"
0 12 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 6 #"Menlo\0"
0 18 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1 0 -1 -1 93 -1 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 35
#"framework:syntax-color:scheme:text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 49
#"framework:syntax-color:scheme:hash-colon-keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 37 #"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 0 36
#"mrlib/syntax-browser:subtitle-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 36 36 140 255 255 255 -1
-1 0 42 #"mrlib/syntax-browser:focused-syntax-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 34 139 34 255 255 255 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1           0 1842 0 28 3 16 #"#lang racket/gui"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";; My first calculator!"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";; Please run in DrRacket."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 72
(4
 #";; To reproduce the exact output, please change the DrRacket setting"
 #"s by"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(5
 #";; selecting 'Language' -> 'Choose Language' under the menus, clicki"
 #"ng on"
) 0 0 24 29 1 #"\n"
0 0 17 3 66
#";; 'Show Details' if the detailed view isn't visible, and changing"
0 0 24 29 1 #"\n"
0 0 17 3 69
(6
 #";; 'Output style' from 'print' to 'write'.  (This keeps DrRacket fro"
 #"m"
) 0 0 24 29 1 #"\n"
0 0 17 3 48 #";; displaying an exta quote mark (') on values.)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";; (Safe to ignore this for right now.)"
0 0 24 29 1 #"\n"
0 0 17 3 87
(7
 #";; namespace magic to make 'eval' work properly in the file (as oppo"
 #"sed to in the REPL)"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 122
(8
 #";; https://stackoverflow.com/questions/20778926/mysterious-racket-er"
 #"ror-define-unbound-identifier-also-no-app-syntax-trans"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 23 #"define-namespace-anchor"
0 0 24 3 1 #" "
0 0 14 3 3 #"anc"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"ns"
0 0 24 3 2 #" ("
0 0 14 3 27 #"namespace-anchor->namespace"
0 0 24 3 1 #" "
0 0 14 3 3 #"anc"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 35 #";; 'define' gives a name to a value"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 2 #" ("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"pi"
0 0 24 3 1 #" "
0 0 21 3 16 #"3.14159265358979"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 28 #";; Racket supports fractions"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 9 #"almost-pi"
0 0 24 3 2 #" ("
0 0 14 3 1 #"/"
0 0 24 3 1 #" "
0 0 21 3 2 #"22"
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";; Our calculator language:"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 28 #";; n     where n is a number"
0 0 24 29 1 #"\n"
0 0 17 3 14 #";; (add e1 e2)"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; (subtract e1 e2)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 58
#";; Racket is a variant of the Scheme programming language."
0 0 24 29 1 #"\n"
0 0 17 3 77
(9
 #";; Scheme, in turn, is a dialect of LISP, which stands for \"List Pr"
 #"ocessing\"."
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";; Creating lists:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; => (3 4 5)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";; => ()    the empty list"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 24 3 3 #"() "
0 0 17 3 17 #";; the empty list"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => ()"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 70
(10
 #";; 'cons' is the list constructor.  'cons' is short for 'constructor"
 #"'."
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 3 #"())"
0 0 24 29 1 #"\n"
0 0 17 3 9 #";; => (3)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #" ("
0 0 14 3 4 #"cons"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 4 #"()))"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; => (4 3)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 48 #";; We can also construct a list using quote ('):"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; => (3 4 5)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";; which is equivalent to:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 5 #"quote"
0 0 24 3 2 #" ("
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; => (3 4 5)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; How quote works:"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 70
(11
 #";; (quote <datum>) => <datum>      (using the explicit 'quote' synta"
 #"x)"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 69
(12
 #";; '<datum> => <datum>             (using the equivalent ' shorthand"
 #")"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 101
(13
 #";; numbers and booleans are \"self-evaluating\"--you don't need to q"
 #"uote a number or a boolean literal:"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 2 #"'5"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 5"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"5"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 5"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 3 #"'#t"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => #t"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 2 #"#t"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => #t"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 3 #"'#f"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => #f"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 2 #"#f"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => #f"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 66
#";; We can also create quote *symbols*, representing symbolic data:"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 14 3 8 #"elephant"
0 0 24 29 1 #"\n"
0 0 17 3 14 #";; => elephant"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 7 #"symbol?"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 4 #"fish"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => #t"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";; We can also quote lists:"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #" ("
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 5 #") ((("
0 0 21 3 1 #"7"
0 0 24 3 4 #"))) "
0 0 21 3 1 #"8"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";; => (3 4 (5 6) (((7))) 8)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 45 #";; Here is an expression that evaluates to 7:"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 7"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 58
#";; Here is a *quoted* expression that evaluates to a list:"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";; => (+ 3 4)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 83
(14
 #";; Adding a quote allows us to treat code as data!!  This is a super"
 #"-power of Lisp!"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 96
(15
 #";; In Scheme/Racket, '+' is just a variable, which is bound to a pro"
 #"cedure that can add numbers:"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 14 3 1 #"+"
0 0 24 29 1 #"\n"
0 0 17 3 20 #";; => #<procedure:+>"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 33 #";; Add quote to produce a symbol:"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => +"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 38 #";; We can create a list of procedures:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 4 #"expt"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 5 #";; =>"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";; (#<procedure:+> #<procedure:-> #<procedure:*> #<procedure:expt>)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 30 #";; Let's give the list a name:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 9 #"operators"
0 0 24 3 2 #" ("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 4 #"expt"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 82
(16
 #";; We can get the first procedure from the list (which is the additi"
 #"on procedure):"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 11 #"my-operator"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 9 #"operators"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 49 #";; and apply that procudure to arguments 3 and 4:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 11 #"my-operator"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 7"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 74
(17
 #";; Let's get the second procedure in the list, which performs subtra"
 #"ction:"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 15 #"second-operator"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 2 #" ("
0 0 14 3 4 #"rest"
0 0 24 3 1 #" "
0 0 14 3 9 #"operators"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 15 #"second-operator"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 8 #";; => -1"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 112
(18
 #";; 'map' applies a procedure of one argument to each element of a li"
 #"st, producing a new list of the same length:"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; => (2 3 4 5 6 7)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 52 #";; The call to 'map' above is equivalent to writing:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 2 #" ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 3 #") ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 3 #") ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #") ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 3 #") ("
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; => (2 3 4 5 6 7)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 50 #";; Let's try using a different procedure and list:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 4 #"sub1"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 17 #";; => (4 3 2 1 0)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";; Let's define a procedure named 'square' that can square a number:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"square"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 3 #") ("
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"square"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 9"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"square"
0 0 24 3 1 #" "
0 0 21 3 2 #"-2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 7 #";; => 4"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";; We can use our 'square' procedure as the first argument to 'map':"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 6 #"square"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 2 #"-3"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 3 #"-11"
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";; => (9 4 121 49)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 101
(19
 #";; We can do the equivalent computation by passing in an *anonymous "
 #"procedure* created with 'lambda'."
) 0 0 24 29 1 #"\n"
0 0 17 3 83
(20
 #";; The procedure is anonymous because we didn't give it a name.  No "
 #"name is needed!"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 3 #") ("
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 3 #")) "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 2 #"-3"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 3 #"-11"
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";; => (9 4 121 49)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";; Let's remember our arthmetic procedures:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 5 #")    "
0 0 17 3 6 #"; => 7"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 5 #")    "
0 0 17 3 7 #"; => -1"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 5 #")    "
0 0 17 3 7 #"; => 12"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"expt"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #") "
0 0 17 3 7 #"; => 81"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 78
(21
 #";; We can do the equivalent computations, collecting the results in "
 #"a list, by"
) 0 0 24 29 1 #"\n"
0 0 17 3 68
#";; mapping over the list of procedures in 'operators' defined above:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"op"
0 0 24 3 3 #") ("
0 0 14 3 2 #"op"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #")) "
0 0 14 3 9 #"operators"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 18 #";; => (7 -1 12 81)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; Another example:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"f"
0 0 24 3 3 #") ("
0 0 14 3 1 #"f"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"     ("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 14 3 1 #"/"
0 0 24 29 1 #"\n"
0 0 24 3 11 #"           "
0 0 14 3 6 #"modulo"
0 0 24 29 1 #"\n"
0 0 24 3 12 #"           ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 14 3 1 #"m"
0 0 24 3 3 #") ("
0 0 14 3 5 #"floor"
0 0 24 3 2 #" ("
0 0 14 3 1 #"/"
0 0 24 3 1 #" "
0 0 14 3 1 #"m"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 5 #")))))"
0 0 24 29 1 #"\n"
0 0 17 3 6 #";; => "
0 0 17 3 1 #"("
0 8          10 17 4 #"3/4\0"
3 #"#e\0"
6 #"mixed\0"
2 #"1\0"
0 0 17 3 5 #" 3 1)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 61
#";; Another example of a *higher order* procedure is 'filter':"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"filter"
0 0 24 3 1 #" "
0 0 14 3 5 #"even?"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 3 #")) "
0 0 17 3 13 #";; => (2 4 6)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"filter"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 3 #") ("
0 0 14 3 1 #">"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 3 #")) "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 2 #"-3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 2 #"-5"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 3 #")) "
0 0 17 3 11 #";; => (4 6)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 79
(22
 #";; Let's define a simple recursive procedure that returns the length"
 #" of a list:"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 3 #"len"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 2 #"ls"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 2 #") "
0 0 17 3 26 #";; is 'ls' the empty list?"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 21 3 1 #"0"
0 0 24 3 10 #"          "
0 0 17 3 18 #";; if so, return 0"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ("
0 0 14 3 4 #"add1"
0 0 24 3 2 #" ("
0 0 14 3 3 #"len"
0 0 24 3 2 #" ("
0 0 14 3 4 #"rest"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 7 #")))))) "
0 0 17 3 69
(23
 #";; otherwise, return one more than the length of the rest of the lis"
 #"t"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 70
(24
 #";; Our 'len' function works, just like the built-in 'length' functio"
 #"n:"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"len"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 1 #"a"
0 0 24 3 1 #" "
0 0 14 3 1 #"b"
0 0 24 3 1 #" "
0 0 14 3 1 #"c"
0 0 24 3 1 #" "
0 0 14 3 1 #"d"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 6 #"))    "
0 0 17 3 7 #";; => 5"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"length"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 1 #"a"
0 0 24 3 1 #" "
0 0 14 3 1 #"b"
0 0 24 3 1 #" "
0 0 14 3 1 #"c"
0 0 24 3 1 #" "
0 0 14 3 1 #"d"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #")) "
0 0 17 3 7 #";; => 5"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 76
(25
 #";; Another recursive definition, which implements a simple variant o"
 #"f 'map':"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"my-map"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"f"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 2 #") "
0 0 17 3 74
(26
 #";; 'f' is a function (procedure), 'ls' is the list we are mapping 'f"
 #"' over"
) 0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 5 #"null?"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 2 #") "
0 0 17 3 37 #";; if 'ls' is the empty list, then..."
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 21 3 1 #"'"
0 0 24 3 10 #"()        "
0 0 17 3 24 #";; return the empty list"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 17 3 66
#";; otherwise, return a new list whose first element is 'f' applied"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 17 3 65
#";; to the first element of 'ls', and whose remaining elements are"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 17 3 51 #";; the result of mapping 'f' over the rest of 'ls'."
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ("
0 0 14 3 4 #"cons"
0 0 24 3 2 #" ("
0 0 14 3 1 #"f"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"my-map"
0 0 24 3 1 #" "
0 0 14 3 1 #"f"
0 0 24 3 2 #" ("
0 0 14 3 4 #"rest"
0 0 24 3 1 #" "
0 0 14 3 2 #"ls"
0 0 24 3 7 #")))))) "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 12 #";; 'my-map' "
0 0 17 3 5 #"works"
0 0 17 3 1 #" "
0 0 17 3 9 #"similarly"
0 0 17 3 1 #" "
0 0 17 3 2 #"to"
0 0 17 3 84
(27
 #" 'map' (the full version of 'map' is more general, and can take more"
 #" than one list!)"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 6 #"my-map"
0 0 24 3 1 #" "
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 3 #")) "
0 0 17 3 17 #";; => (2 3 4 5 6)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 14 3 4 #"add1"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 6 #"))    "
0 0 17 3 17 #";; => (2 3 4 5 6)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; Quote refresher."
0 0 24 29 1 #"\n"
0 0 17 3 24 #";; The quoted expression"
0 0 24 29 1 #"\n"
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; is equivalent to"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 2 #"'3"
0 0 24 3 1 #" "
0 0 21 3 2 #"'4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";; which is equivalent to"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 72
(28
 #";; Scheme/Racket also supports *quasiquote*, for \"almost constant d"
 #"ata\":"
) 0 0 24 29 1 #"\n"
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";; is equivalent to"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";; Here is a slightly more sophisticated use of quasiquote:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 13 #"make-add-list"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 1 #"m"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"    "
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 1 #"m"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 13 #"make-add-list"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 3 #")  "
0 0 17 3 13 #";; => (+ 3 6)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 13 #"make-add-list"
0 0 24 3 1 #" "
0 0 21 3 2 #"17"
0 0 24 3 2 #") "
0 0 17 3 14 #";; => (+ 17 6)"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 13 #"make-add-list"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 3 #")  "
0 0 17 3 13 #";; => (+ 5 6)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 94
(29
 #";; We can then evaluate the resulting list, as if we had typed it in"
 #" at the interpreter prompt"
) 0 0 24 29 1 #"\n"
0 0 17 3 4 #";; ("
0 0 17 3 3 #"the"
0 0 17 3 1 #" "
0 0 17 3 4 #"REPL"
0 0 17 3 1 #" "
0 0 17 3 2 #"--"
0 0 17 3 1 #" "
0 0 17 3 4 #"Read"
0 0 17 3 1 #" "
0 0 17 3 4 #"Eval"
0 0 17 3 1 #" "
0 0 17 3 5 #"Print"
0 0 17 3 1 #" "
0 0 17 3 6 #"Loop)."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 86
(30
 #";; (the 'ns' \"namespace\" argument to 'eval' tells 'eval' which var"
 #"iables are in scope)"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"eval"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #") "
0 0 14 3 2 #"ns"
0 0 24 3 2 #") "
0 0 17 3 3 #";; "
0 0 17 3 2 #"=>"
0 0 17 3 2 #" 7"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 27 #";; Time for calculator fun!"
0 0 24 29 1 #"\n"
0 0 17 3 52 #";; We will use *pattern matching* in our calculator."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";; Let's define an expression in our calculator language:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 13 #"my-expression"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 2 #" ("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #") "
0 0 21 3 1 #"5"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";; We can use Racket's 'match' form to perform pattern matching:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 5 #"match"
0 0 24 3 1 #" "
0 0 14 3 13 #"my-expression"
0 0 24 3 1 #" "
0 0 17 3 77
(31
 #";; we are matching against the value of 'my-expression', which is th"
 #"e list '("
) 0 0 17 3 3 #"add"
0 0 17 3 2 #" ("
0 0 17 3 3 #"sub"
0 0 17 3 1 #" "
0 0 17 3 1 #"3"
0 0 17 3 1 #" "
0 0 17 3 1 #"4"
0 0 17 3 2 #") "
0 0 17 3 3 #"5)'"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 3 #")  "
0 0 17 3 106
(32
 #";; Here is the pattern we are matching against: a list of length 3, "
 #"which first element is the symbol 'add"
) 0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"matched add expression\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e1: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e2: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 29 #";; Let's try another example:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"expr2"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 2 #" ("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 3 #") ("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #" ("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 5 #"match"
0 0 24 3 1 #" "
0 0 14 3 5 #"expr2"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"matched add expression\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e1: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"   ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e2: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #")])"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 118
(33
 #";; We can build a dumb calculator that just prints out information a"
 #"bout the expression 'expr' that is matched against"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 11 #"simple-calc"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 4 #"expr"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 5 #"match"
0 0 24 3 1 #" "
0 0 14 3 4 #"expr"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"      [("
0 0 14 3 1 #"?"
0 0 24 3 1 #" "
0 0 14 3 7 #"number?"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 18 #"\"matched number\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 14 #"\"number: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"matched add expression\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e1: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e2: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 26 #"\"matched sub expression\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e1: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 10 #"\"e2: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 5 #")])))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 22 #";; Try a few examples:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 11 #"simple-calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 11 #"simple-calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 2 #" ("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 3 #") ("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 11 #"simple-calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 11 #"simple-calc"
0 0 24 3 1 #" "
0 0 21 3 3 #"'42"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 29 #";; Here is a real calculator!"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"calc"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 4 #"expr"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 15 3 5 #"match"
0 0 24 3 1 #" "
0 0 14 3 4 #"expr"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"      [("
0 0 14 3 1 #"?"
0 0 24 3 1 #" "
0 0 14 3 7 #"number?"
0 0 24 3 1 #" "
0 0 14 3 1 #"n"
0 0 24 3 2 #") "
0 0 17 3 27 #";; matches against a number"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"       "
0 0 14 3 1 #"n"
0 0 24 3 2 #"] "
0 0 17 3 21 #";; returns the number"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 17 3 38 #";; matches against an 'add' expression"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 1 #"+"
0 0 24 3 2 #" ("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 4 #"))] "
0 0 17 3 71
(34
 #";; uses Racket's '+' to add the result of the recursive calls to 'ca"
 #"lc'"
) 0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 17 3 37 #";; matches against a 'sub' expression"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 1 #"-"
0 0 24 3 2 #" ("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 4 #"))] "
0 0 17 3 76
(35
 #";; uses Racket's '-' to subtract the result of the recursive calls t"
 #"o 'calc'"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 18 #";; TODO next time!"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 17 3 104
(36
 #";; Implement these three lambda-calculus expressions to get a full T"
 #"uring-complete programming language!"
) 0 0 24 29 1 #"\n"
0 0 24 3 8 #"      [("
0 0 14 3 1 #"?"
0 0 24 3 1 #" "
0 0 14 3 7 #"symbol?"
0 0 24 3 1 #" "
0 0 14 3 1 #"x"
0 0 24 3 2 #") "
0 0 17 3 37 #";; variables (represented as symbols)"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"       "
0 0 21 3 1 #"'"
0 0 14 3 4 #"TODO"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ]"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 28 3 1 #","
0 0 14 3 1 #"x"
0 0 24 3 2 #") "
0 0 28 3 1 #","
0 0 14 3 4 #"body"
0 0 24 3 3 #")  "
0 0 17 3 36 #";; lambda expression, or abstraction"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"       "
0 0 21 3 1 #"'"
0 0 14 3 4 #"TODO"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ]"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ["
0 0 21 3 1 #"`"
0 0 24 3 1 #"("
0 0 28 3 1 #","
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 17 3 24 #";; procedure application"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"       "
0 0 21 3 1 #"'"
0 0 14 3 4 #"TODO"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"      "
0 0 24 29 1 #"\n"
0 0 24 3 9 #"      )))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 21 3 3 #"'42"
0 0 24 3 2 #") "
0 0 17 3 7 #"; => 42"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #")) "
0 0 17 3 6 #"; => 7"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 2 #" ("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #") ("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 4 #"))) "
0 0 17 3 7 #"; => 18"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"add"
0 0 24 3 2 #" ("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 3 #") ("
0 0 14 3 3 #"add"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 4 #"))) "
0 0 17 3 6 #"; => 8"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 24 3 1 #"("
0 0 14 3 3 #"sub"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #")) "
0 0 17 3 7 #"; => -1"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 45 #";; Simple calculator Graphical User Interface"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 87
(37
 #";; Uses the Racket GUI toolkit, which uses message-passing OOP (insp"
 #"ired by Smalltalk!)"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 36 #";; https://docs.racket-lang.org/gui/"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 55 #";; https://docs.racket-lang.org/gui/Widget_Gallery.html"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";; Create the main window"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 17 #"calculator-window"
0 0 24 3 2 #" ("
0 0 14 3 3 #"new"
0 0 24 3 1 #" "
0 0 14 3 6 #"frame%"
0 0 24 29 1 #"\n"
0 0 24 3 29 #"                            ("
0 0 14 3 5 #"label"
0 0 24 3 1 #" "
0 0 19 3 12 #"\"Calculator\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 29 #"                            ("
0 0 14 3 5 #"width"
0 0 24 3 1 #" "
0 0 21 3 3 #"400"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 95
(38
 #";; Create a text field for the user to enter an expression, such as "
 #"\"(add (sub 3 4) (add 5 6))\""
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 15 #"expr-text-field"
0 0 24 3 2 #" ("
0 0 14 3 3 #"new"
0 0 24 3 1 #" "
0 0 14 3 11 #"text-field%"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 5 #"label"
0 0 24 3 1 #" "
0 0 19 3 12 #"\"Expression\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 6 #"parent"
0 0 24 3 1 #" "
0 0 14 3 17 #"calculator-window"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 10 #"init-value"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"\""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 96
(39
 #";; The user presses the 'Calculate' button to call 'calc' on the exp"
 #"ression in 'expr-text-field'"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 16 #"calculate-button"
0 0 24 3 2 #" ("
0 0 14 3 3 #"new"
0 0 24 3 1 #" "
0 0 14 3 7 #"button%"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 6 #"parent"
0 0 24 3 1 #" "
0 0 14 3 17 #"calculator-window"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 5 #"label"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"Calculate\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 8 #"callback"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 4 #"this"
0 0 24 3 1 #" "
0 0 14 3 5 #"event"
0 0 24 3 2 #") "
0 0 17 3 63
#";; this anonymous function is called when the button is pressed"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 33 #"\"Calculate button was clicked!\\n\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 11 #"expr-string"
0 0 24 3 2 #" ("
0 0 14 3 4 #"send"
0 0 24 3 1 #" "
0 0 14 3 15 #"expr-text-field"
0 0 24 3 1 #" "
0 0 14 3 9 #"get-value"
0 0 24 3 3 #")) "
0 0 17 3 18 #";; send a message!"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 30 #"\"expression as a string: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 11 #"expr-string"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"expr"
0 0 24 3 2 #" ("
0 0 15 3 22 #"with-input-from-string"
0 0 24 3 1 #" "
0 0 14 3 11 #"expr-string"
0 0 24 3 2 #" ("
0 0 15 3 6 #"lambda"
0 0 24 3 5 #" () ("
0 0 14 3 4 #"read"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 34 #"\"parsed symbolic expression: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 4 #"expr"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"value"
0 0 24 3 2 #" ("
0 0 14 3 4 #"calc"
0 0 24 3 1 #" "
0 0 14 3 4 #"expr"
0 0 24 3 3 #")) "
0 0 17 3 38 #";; call our 'calc' function from above"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 14 3 6 #"printf"
0 0 24 3 1 #" "
0 0 19 3 24 #"\"calculated value: ~s\\n\""
0 0 24 3 1 #" "
0 0 14 3 5 #"value"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 39 #"                                      ("
0 0 14 3 4 #"send"
0 0 24 3 1 #" "
0 0 14 3 13 #"value-message"
0 0 24 3 1 #" "
0 0 14 3 9 #"set-label"
0 0 24 3 2 #" ("
0 0 14 3 6 #"format"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"~a\""
0 0 24 3 1 #" "
0 0 14 3 5 #"value"
0 0 24 3 6 #"))))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";; Placeholder for the resulting value to be displayed"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 13 #"value-message"
0 0 24 3 2 #" ("
0 0 14 3 3 #"new"
0 0 24 3 1 #" "
0 0 14 3 8 #"message%"
0 0 24 29 1 #"\n"
0 0 24 3 25 #"                        ("
0 0 14 3 6 #"parent"
0 0 24 3 1 #" "
0 0 14 3 17 #"calculator-window"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 25 #"                        ("
0 0 14 3 5 #"label"
0 0 24 3 1 #" "
0 0 19 3 14 #"\"            \""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";; Display the window"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 4 #"send"
0 0 24 3 1 #" "
0 0 14 3 17 #"calculator-window"
0 0 24 3 1 #" "
0 0 14 3 4 #"show"
0 0 24 3 1 #" "
0 0 21 3 2 #"#t"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0           0
